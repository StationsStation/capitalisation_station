# ------------------------------------------------------------------------------
#
#   Copyright 2023
#   Copyright 2023 valory-xyz
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

from typing import Any
from datetime import datetime
from textwrap import dedent
from collections.abc import Generator

from aea.configurations.base import PublicId

from packages.eightballer.connections.dcxt import PUBLIC_ID as DCXT_PUBLIC_ID
from packages.eightballer.skills.simple_fsm.enums import ArbitrageabciappEvents
from packages.eightballer.protocols.orders.message import OrdersMessage
from packages.eightballer.skills.simple_fsm.strategy import TZ, AgentState, ArbitrageStrategy
from packages.eightballer.protocols.orders.custom_types import Order, OrderStatus
from packages.eightballer.connections.ccxt_wrapper.connection import PUBLIC_ID as CCXT_PUBLIC_ID
from packages.eightballer.skills.simple_fsm.behaviour_classes.base import BaseConnectionRound


DEFAULT_ENCODING = "utf-8"

# Define states

PORTFOLIO_FILE = "portfolio.json"
EXISTING_ORDERS_FILE = "existing_orders.json"
FAILED_ORDERS_FILE = "failed_orders.json"
ORDERS_FILE = "orders.json"
PRICES_FILE = "prices.json"

ORDER_PLACEMENT_TIMEOUT_SECONDS = 30


class UnexpectedStateException(Exception):
    """Exception raised when an unexpected state is reached."""


class ExecuteOrdersRound(BaseConnectionRound):
    """This class implements the ExecuteOrdersRound state."""

    matching_round = "executeordersround"
    supported_protocols: dict[PublicId, list] = {
        OrdersMessage.protocol_id: [],
    }

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False
        self._message = None
        self.failed: ArbitrageabciappEvents | None = None

    def setup(self) -> None:
        """Setup the state."""
        super().setup()
        self.failed = None
        self.started_at: datetime | None = None
        for k in self.supported_protocols:
            self.supported_protocols[k] = []

    def has_timed_out(self) -> bool:
        """Check if the state has timed out."""
        if self.started_at is None:
            return False
        return (datetime.now(tz=TZ) - self.started_at).total_seconds() > ORDER_PLACEMENT_TIMEOUT_SECONDS

    def process_new_order_queue(self) -> None:
        """Process the new order queue."""
        state: AgentState = self.strategy.state
        if self.strategy.state.new_orders and not state.submitted_orders:
            if not self.started_at:
                self.started_at = datetime.now(tz=TZ)
            self.started = True
            order = self.strategy.state.new_orders.pop(0)
            self.context.logger.info(f"Creating order: {order}")
            is_entry_order = len(state.new_orders) > 1
            is_exit_order = len(state.new_orders) == 1
            self.send_create_order(
                order=order,
                is_entry_order=is_entry_order,
                is_exit_order=is_exit_order,
            )
            state.submitted_orders.append(order)
            return

    def process_submitted_order_queue(self) -> None:
        """Process the submitted order queue."""
        state: AgentState = self.strategy.state
        inbound = self.supported_protocols.get(OrdersMessage.protocol_id, [])
        if len(inbound) > 1:
            self.context.logger.error("Multiple inbound messages received.")
            msg = "Multiple inbound messages received."
            raise UnexpectedStateException(msg)
        order_result = inbound.pop()
        is_entry_order = len(state.new_orders) == 1
        is_exit_order = len(state.new_orders) == 0
        if order_result.performative is not OrdersMessage.Performative.ERROR:
            is_as_expected = self.handle_submitted_order_response(
                order=order_result.order,
            )
            self.context.logger.info(f"Order created: {order_result.order} is as expected: {is_as_expected}")
            if not is_as_expected:
                if is_entry_order:
                    self._handle_failed_entry_order(order_result.order)
                else:
                    self._handle_failed_exit_order("Error creating order")
            else:
                if is_entry_order:
                    self.strategy.entry_order = order_result.order
                if is_exit_order:
                    self.strategy.exit_order = order_result.order
                self.context.logger.info(f"Everything is ok: {is_as_expected}")
            return
        msg = "Error creating order"
        raise UnexpectedStateException(msg)

    def act(self) -> None:
        """Perform the action of the state."""
        state: AgentState = self.strategy.state

        if self.supported_protocols.get(OrdersMessage.protocol_id):
            self.context.logger.debug("Processing submitted orders")
            self.process_submitted_order_queue()
            return

        if state.new_orders and not state.submitted_orders:
            self.context.logger.debug("Processing new orders")
            self.process_new_order_queue()
            return

        if self.failed is not None:
            self.context.logger.error("Failed to create order")
            self._event = self.failed
            self._is_done = True
            return

        if self.started and not state.new_orders and not state.submitted_orders:
            self._event = ArbitrageabciappEvents.DONE
            self._is_done = True
            return

        if self.has_timed_out():
            self.context.logger.error("Timeout creating order")
            is_entry_order = len(state.new_orders) == 1
            is_exit_order = len(state.new_orders) == 0
            if is_entry_order:
                self._handle_failed_entry_order(state.submitted_orders[0], "Timeout creating order")
            if is_exit_order:
                msg = "Recovery orders are not yet supported."
                self._handle_failed_exit_order(msg)

    def _handle_failed_entry_order(
        self,
        order: Order,
        msg: str = "Error creating entry order",
    ) -> None:
        self.context.logger.error(msg)
        self.context.logger.error(f"Error creating order: {order}")
        self._is_done = True
        self.failed = ArbitrageabciappEvents.ENTRY_EXIT_ERROR
        self._event = self.failed
        self.reset_state()

    def reset_state(self) -> None:
        """Reset the state."""
        self.strategy.state.new_orders = []
        self.strategy.state.submitted_orders = []
        self.supported_protocols[OrdersMessage.protocol_id] = []

    def _handle_failed_exit_order(
        self,
        msg: str,
    ) -> None:
        self.context.logger.error(msg)
        raise UnexpectedStateException(msg)

    def send_create_order(
        self,
        order: Order,
        is_entry_order: bool,
        is_exit_order: bool,
    ) -> Generator:
        """Send the create order message."""
        response = self.submit_msg(
            OrdersMessage.Performative.CREATE_ORDER,
            connection_id=CCXT_PUBLIC_ID if order.ledger_id == "cex" else DCXT_PUBLIC_ID,
            order=order,
            ledger_id=order.ledger_id,
            exchange_id=order.exchange_id,
        )
        response.is_entry_order = is_entry_order
        response.is_exit_order = is_exit_order
        response.validate_func = self._validate_order_response

    def _validate_order_response(
        self,
        order: Order,
        response: OrdersMessage | None,
        is_entry_order: bool,
        is_exit_order: bool,
    ) -> OrdersMessage | None:
        """Validate the order response."""

        if response is None:
            self.context.logger.error(f"Timeout creating order: {order}")
            if is_entry_order:
                return self._handle_failed_entry_order(order)
            if is_exit_order:
                msg = (
                    "Recovery orders are not yet supported."
                    + "Timeout creating order, Hard exiting as manual adjustment needed!"
                )
                return self._handle_failed_exit_order(msg)
        if response.performative is OrdersMessage.Performative.ERROR or response.order.status is OrderStatus.FAILED:
            self.context.logger.error(f"Error creating order: {order} response: {response}")
            if is_entry_order:
                return self._handle_failed_entry_order(order)
            if is_exit_order:
                msg = f"Error creating order: {response} {order}"
                return self._handle_failed_exit_order(msg)
        return response

    def handle_submitted_order_response(
        self,
        order: Order,
    ) -> bool:
        """Handle the order submission response."""

        if order.status == OrderStatus.PARTIALLY_FILLED:
            msg = "Partially filled orders are not yet supported."
            raise UnexpectedStateException(msg)

        if order.status in (
            {
                OrderStatus.FILLED,
                OrderStatus.OPEN,
                OrderStatus.NEW,
            }
        ):
            self.context.logger.info("Order created:")
            self.context.logger.info(
                dedent(f"""
            Id: {order.id}
            Exchange: {order.exchange_id}
            Market:   {order.symbol}
            Status:   {order.status}
            Side:     {order.side}
            Price:    {order.price}
            Amount:   {order.amount}
            Filled Amount:   {order.filled}
            """)
            )
            if order.status == OrderStatus.FILLED:
                self.context.logger.info("Order filled.")
                self.strategy.state.submitted_orders.pop()  # we make the assumption we only have one order...
                return True
            if order.status in {
                OrderStatus.OPEN,
                OrderStatus.NEW,
            }:
                self.context.logger.info("Order created.")
                self.strategy.state.submitted_orders.pop()  # we make the assumption we only have one order...
                return True
            msg = f"This is a completely unexpected error. Order {order}"
            raise UnexpectedStateException(msg)
        if order.status == OrderStatus.FAILED:
            self.context.logger.error(f"Order failed: {order}")
            self.strategy.state.failed_orders.append(order)
            self.strategy.state.submitted_orders.pop()  # we make the assumption we only have one order...
            return False

        if order.status == OrderStatus.CANCELLED:
            # If we have a cancelled order, and we have Some of it filled we need to handle it.
            filled_amt = order.filled
            if filled_amt > 0:
                self.context.logger.info(f"Order cancelled: {order} with filled amount: {filled_amt}")
                # we get te other order and modify the amount
                if len(self.strategy.state.new_orders) == 1:
                    self.strategy.state.submitted_orders.pop()
                    self.strategy.state.new_orders[0].amount = filled_amt
                    self.context.logger.info(
                        f"Is entry order, so modifying amount: {self.strategy.state.new_orders[0].amount}"
                    )
                    return True

        msg = "This is a placeholder for currently unhandled methods within recieved orders."
        self.context.logger.error(msg)
        raise UnexpectedStateException(msg)

    @property
    def strategy(self) -> ArbitrageStrategy:
        """Return the strategy."""
        return self.context.arbitrage_strategy

    def handle_order(self, order: Order) -> None:
        """Handle the order."""
