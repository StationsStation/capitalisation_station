# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023
#   Copyright 2023 valory-xyz
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import sys
import json
import asyncio
import pathlib
import datetime
from abc import ABC
from enum import Enum
from time import sleep
from typing import Any, Callable, Optional, Generator, cast
from textwrap import dedent
from dataclasses import asdict

from aea.mail.base import Message
from aea.skills.behaviours import State, FSMBehaviour
from aea.protocols.dialogue.base import Dialogue

from packages.eightballer.connections.ccxt import PUBLIC_ID as CCXT_PUBLIC_ID
from packages.eightballer.connections.dcxt import PUBLIC_ID as DCXT_PUBLIC_ID
from packages.eightballer.protocols.orders.message import OrdersMessage
from packages.eightballer.protocols.tickers.message import TickersMessage
from packages.eightballer.protocols.balances.message import BalancesMessage
from packages.eightballer.protocols.orders.custom_types import Order
from packages.eightballer.connections.apprise.connection import CONNECTION_ID as APPRISE_PUBLIC_ID
from packages.eightballer.protocols.user_interaction.message import UserInteractionMessage
from packages.eightballer.protocols.user_interaction.dialogues import UserInteractionDialogues
from packages.valory.skills.abstract_round_abci.behaviour_utils import BaseBehaviour, TimeoutException


# Define states

PORTFOLIO_FILE = "portfolio.json"
EXISTING_ORDERS_FILE = "existing_orders.json"
ORDERS_FILE = "orders.json"
PRICES_FILE = "prices.json"

TIMEOUT_SECONDS = 10

TZ = datetime.datetime.now().astimezone().tzinfo


class SetupRound(State):
    """
    This class implements the SetupRound state.
    """

    clear_data = False

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """
        Perform the action of the state.
        """
        self.context.logger.info("SetupRound: Performing action")
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)
        if self.clear_data:
            for f in ["orders.json", "portfolio.json", "prices.json"]:
                if pathlib.Path(f).exists():
                    pathlib.Path(f).unlink()
        # We also ensure all behaviours are setup
        self.context.behaviours.main.setup()
        self._is_done = True

    def is_done(self) -> bool:
        """
        Return True if the state is done.
        """
        return self._is_done

    @property
    def event(self) -> Optional[str]:
        """
        Return the event.
        """
        return self._event


class IdentifyOpportunityRound(State):
    """
    This class implements the IdentifyOpportunityRound state.
    """

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done

        # we have to import the strategy due to the loading sequence of the agent dependencies.

    async def act(self) -> None:
        """
        Perform the action of the state.
        """
        if self.started:
            return
        print("IdentifyOpportunityRound: Performing action")
        self.started = True
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        portfolio = json.loads(pathlib.Path(PORTFOLIO_FILE).read_text())
        prices = json.loads(pathlib.Path(PRICES_FILE).read_text())
        existing_orders = json.loads(pathlib.Path(EXISTING_ORDERS_FILE).read_text())

        orders = self.arbitrage_strategy.get_orders(portfolio=portfolio, prices=prices, existing_orders=existing_orders)
        if orders:
            self.context.logger.info(f"Opportunity found: {orders}")
            orders = [json.loads(o.model_dump_json()) for o in orders]
            pathlib.Path(ORDERS_FILE).write_text(json.dumps(orders, indent=4))
            self._event = ArbitrageabciappEvents.OPPORTUNITY_FOUND
        await asyncio.sleep(0)

    def is_done(self) -> bool:
        """
        Return True if the state is done.
        """
        return self._is_done

    @property
    def event(self) -> Optional[str]:
        """
        Return the event.
        """
        return self._event

    def setup(self) -> None:
        """
        Setup the state.
        """
        self.started = False
        # We need to add to the PYTHONPATH=. to be able to import the strategy
        sys.path.append(".")
        from vendor.eightballer.customs.arbitrage_strategy import strategy as ArbitrageStrategy  # noqa

        self.arbitrage_strategy = ArbitrageStrategy()


class ErrorRound(State):
    """
    This class implements the ErrorRound state.
    """

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """
        Perform the action of the state.
        """
        print("ErrorRound: Performing action")
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(1)

    def is_done(self) -> bool:
        """
        Return True if the state is done.
        """
        return self._is_done

    @property
    def event(self) -> Optional[str]:
        """
        Return the event.
        """
        return self._event


class BaseConnectionRound(BaseBehaviour):
    """
    This class implements the BaseConnectionRound state.
    """

    matching_round = "baseconnectionround"

    def setup(self) -> None:
        """
        Setup the state.
        """
        self._performative_to_dialogue_class = {
            OrdersMessage.Performative.GET_ORDERS: self.context.orders_dialogues,
            OrdersMessage.Performative.CREATE_ORDER: self.context.orders_dialogues,
            BalancesMessage.Performative.GET_ALL_BALANCES: self.context.balances_dialogues,
            TickersMessage.Performative.GET_ALL_TICKERS: self.context.tickers_dialogues,
        }
        self.started = False
        self._is_done = False  # noqa
        self._message = None  # noqa

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self._message = None  # noqa

    def is_done(self) -> bool:
        """
        Return True if the state is done.
        """
        return self._is_done  # noqa

    @property
    def current_message(self) -> None:
        """
        Return the current message.
        """
        return self._message  # noqa

    def get_response(
        self,
        protocol_performative: Message.Performative,
        connection_id: str,
        **kwargs,
    ) -> Generator[None, None, Any]:
        """
        Get a ccxt response.
        """

        dialogue_class = self._performative_to_dialogue_class[protocol_performative]

        msg, dialogue = dialogue_class.create(
            counterparty=str(connection_id),
            performative=protocol_performative,
            **kwargs,
        )
        msg._sender = str(self.context.skill_id)  # noqa
        response = yield from self._do_request(msg, dialogue)
        self._message = None
        return response

    def get_callback_request(self) -> Callable[[Message, "BaseBehaviour"], None]:
        """Wrapper for callback request which depends on whether the message has not been handled on time.

        :return: the request callback.
        """

        def callback_request(message: Message, current_behaviour: BaseBehaviour) -> None:
            """The callback request."""
            self.context.logger.debug(f"Callback request: {message}")
            current_behaviour._message = message  # noqa

        return callback_request

    def wait_for_message(
        self,
        condition: Callable = lambda message: True,  # noqa
        timeout: Optional[float] = None,
    ) -> Any:
        """
        Wait for message.

        Care must be taken. This method does not handle concurrent requests.
        Use directly after a request is being sent.
        This is a local method that does not depend on the global clock,
        so the usage of datetime.now() is acceptable here.

        :param condition: a callable
        :param timeout: max time to wait (in seconds)
        :return: a message
        :yield: None
        """
        if timeout is not None:
            deadline = datetime.datetime.now(tz=TZ) + datetime.timedelta(0, timeout)
        else:
            deadline = datetime.datetime.max

        try:
            while self.current_message is None:
                yield  # noqa
                if timeout is not None and datetime.datetime.now(tz=TZ) > deadline:
                    raise TimeoutException()
            self.context.logger.debug(f"Received message: {self._message}")
            return self.current_message
        except TimeoutException:
            self.context.logger.info("Timeout!")
            return None  # noqa

    @property
    def event(self) -> Optional[str]:
        """
        Return the event.
        """
        return self._event

    async def async_act_wrapper(self) -> Generator[Any, None, None]:
        """
        Wrapper for the async act method.
        """
        return await self.async_act()

    async def async_act(self) -> None:
        """
        Perform the action of the state.
        """
        self.act()


class ExecuteOrdersRound(BaseConnectionRound):
    """
    This class implements the ExecuteOrdersRound state.
    """

    matching_round = "executeordersround"

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False
        self._message = None

    def act(self) -> None:
        """
        Perform the action of the state.
        """
        if self.started:
            return
        self.started = True
        print("ExecuteOrdersRound: Performing action")

        order_file = pathlib.Path("orders.json")
        orders = order_file.read_text()
        orders = json.loads(orders)
        models = [Order.model_validate(o) for o in orders]
        for order in models:
            # We send the orders to the exchange.
            response = yield from self.get_response(
                OrdersMessage.Performative.CREATE_ORDER,
                connection_id=CCXT_PUBLIC_ID if order.ledger_id == "cex" else DCXT_PUBLIC_ID,
                order=order,
                ledger_id=order.ledger_id,
                exchange_id=order.exchange_id,
            )
            self.context.logger.info(
                dedent(f"""
            Id: {response.order.id}
            Exchange: {response.order.exchange_id} 
            Market:   {response.order.symbol} 
            Status:   {response.order.status} 
            Side:     {response.order.side}
            Price:    {response.order.price}
            Amount:   {response.order.amount}
            """)
            )

        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE


class CollectDataRound(BaseConnectionRound):
    """
    This class implements the CollectDataRound state.
    """

    matching_round = "collectdataround"

    def act(self) -> Generator:
        """
        Perform the action of the state.
        """
        if self.started:
            return

        self.started = True

        portfolio = {}
        ledger_id = "cex"
        prices = {ledger_id: {}}
        existing_orders = {ledger_id: {}}
        portfolio[ledger_id] = {}
        for exchange_id in self.context.arbitrage_strategy.cexs:
            balances = yield from self.get_response(
                BalancesMessage.Performative.GET_ALL_BALANCES,
                connection_id=str(CCXT_PUBLIC_ID),
                exchange_id=exchange_id,
            )

            if balances.performative == BalancesMessage.Performative.ERROR:
                self.context.logger.error(f"Error getting balances for {exchange_id} on {ledger_id}")
                self.started = False
                sleep(TIMEOUT_SECONDS)
                return

            tickers = yield from self.get_response(
                TickersMessage.Performative.GET_ALL_TICKERS, connection_id=str(CCXT_PUBLIC_ID), exchange_id=exchange_id
            )
            orders = yield from self.get_response(
                OrdersMessage.Performative.GET_ORDERS,
                connection_id=str(CCXT_PUBLIC_ID),
                exchange_id=exchange_id,
                symbol="OLAS/USDT",
            )

            portfolio[ledger_id][exchange_id] = [b.dict() for b in balances.balances.balances]
            prices[ledger_id][exchange_id] = [t.dict() for t in tickers.tickers.tickers]
            existing_orders[ledger_id][exchange_id] = [o.model_dump() for o in orders.orders.orders]

        for exchange_id in self.context.arbitrage_strategy.dexs:
            for ledger_id in self.context.arbitrage_strategy.ledgers:
                if ledger_id not in portfolio:
                    portfolio[ledger_id] = {}
                if ledger_id not in prices:
                    prices[ledger_id] = {}

                self.context.logger.info(f"Getting balances for {exchange_id} on {ledger_id}")
                balances = yield from self.get_response(
                    BalancesMessage.Performative.GET_ALL_BALANCES,
                    connection_id=str(DCXT_PUBLIC_ID),
                    exchange_id=exchange_id,
                    ledger_id=ledger_id,
                )
                tickers = yield from self.get_response(
                    TickersMessage.Performative.GET_ALL_TICKERS,
                    connection_id=str(DCXT_PUBLIC_ID),
                    exchange_id=exchange_id,
                    ledger_id=ledger_id,
                )
                self.context.logger.info(f"Got balances for {exchange_id} on {ledger_id}")
                self.context.logger.info(f"Got tickers for {exchange_id} on {ledger_id}")
                self.context.logger.info(f"Balances: {balances}")
                self.context.logger.info(f"Tickers: {tickers}")
                portfolio[ledger_id][exchange_id] = [b.dict() for b in balances.balances.balances]
                prices[ledger_id][exchange_id] = [t.dict() for t in tickers.tickers.tickers]

        # We write the portfolio to disk
        self.context.logger.info(f"Portfolio: {portfolio}")
        pathlib.Path(PORTFOLIO_FILE).write_text(json.dumps(portfolio, indent=4))
        pathlib.Path(PRICES_FILE).write_text(json.dumps(prices, indent=4))
        pathlib.Path(EXISTING_ORDERS_FILE).write_text(json.dumps(existing_orders, indent=4))

        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE


class PostTradeRound(State):
    """This class implements the PostTradeRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.setup()

    def setup(self) -> None:
        """Setup the state."""
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        print("PostTradeRound: Performing action")
        if self.started:
            return
        self.started = True
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)
        order_file = pathlib.Path("orders.json")
        orders = order_file.read_text()
        orders = json.loads(orders)
        sell_order, buy_order = [Order.model_validate(o) for o in orders]

        report_msg = f"""
        ```
        Sell Order:
            Exchange: {sell_order.exchange_id}
            Market:   {sell_order.symbol}
            Status:   {sell_order.status}
            Side:     {sell_order.side}
            Price:    {sell_order.price}
            Amount:   {sell_order.amount}
        Buy Order:
            Exchange: {buy_order.exchange_id}
            Market:   {buy_order.symbol}
            Status:   {buy_order.status}
            Side:     {buy_order.side}
            Price:    {buy_order.price}
            Amount:   {buy_order.amount}

        Profit %: {- (buy_order.price / sell_order.price * 100 - 100)}
        ```
        """

        self.send_notification_to_user(
            title="Post Trade Execution!",
            msg=report_msg,
        )

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> Optional[str]:
        """Return the event."""
        return self._event

    def send_notification_to_user(self, title: str, msg: str, attach: str = None) -> None:
        """Send notification to user."""
        dialogues = cast(UserInteractionDialogues, self.context.user_interaction_dialogues)
        msg, _ = dialogues.create(
            counterparty=str(APPRISE_PUBLIC_ID),
            performative=UserInteractionMessage.Performative.NOTIFICATION,
            title=title,
            body=msg,
            attach=attach,
        )
        self.context.outbox.put_message(message=msg)


class NoOpportunityRound(State):
    """This class implements the NoOpportunityRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        print("NoOpportunityRound: Performing action")
        self._is_done = True  # noqa
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)

    def setup(self) -> None:
        """Setup the state."""
        self.started = False
        self._is_done = False  # noqa
        super().setup()

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done  # noqa

    @property
    def event(self) -> Optional[str]:
        """Return the event."""
        return self._event  # noqa


class ArbitrageabciappEvents(Enum):
    """This class defines the events for the Arbitrageabciapp FSM."""

    DONE = "DONE"
    TIMEOUT = "TIMEOUT"
    OPPORTUNITY_FOUND = "OPPORTUNITY_FOUND"


class ArbitrageabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state("setupround", SetupRound(**kwargs), True)

        self.register_state("errorround", ErrorRound(**kwargs))
        self.register_state("posttraderound", PostTradeRound(**kwargs), False)
        self.register_state("noopportunityround", NoOpportunityRound(**kwargs))

        self.register_state(
            "identifyopportunityround",
            IdentifyOpportunityRound(**kwargs),
        )
        self.register_state(
            "executeordersround",
            ExecuteOrdersRound(**kwargs),
        )
        self.register_state("collectdataround", CollectDataRound(**kwargs))

        self.register_transition(source="setupround", event=ArbitrageabciappEvents.DONE, destination="collectdataround")
        self.register_transition(
            source="collectdataround", event=ArbitrageabciappEvents.DONE, destination="identifyopportunityround"
        )
        self.register_transition(
            source="identifyopportunityround",
            event=ArbitrageabciappEvents.OPPORTUNITY_FOUND,
            destination="executeordersround",
        )
        self.register_transition(
            source="identifyopportunityround", event=ArbitrageabciappEvents.DONE, destination="noopportunityround"
        )
        self.register_transition(
            source="executeordersround", event=ArbitrageabciappEvents.DONE, destination="posttraderound"
        )
        self.register_transition(source="posttraderound", event=ArbitrageabciappEvents.DONE, destination="setupround")
        # register a transation from noopportunityround to setupround
        self.register_transition(
            source="noopportunityround", event=ArbitrageabciappEvents.DONE, destination="setupround"
        )
        # register a transation from posttraderound to setupround

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Arbitrageabciapp FSM behaviour.")
        # We need to setup all the states.
        for state_name in self.states:
            state = self.get_state(state_name)
            state._is_done = False  # noqa
            state.setup()

        self.current_task = None

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Arbitrageabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the behaviour."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
            return

        if self.current_task:
            if not self.current_task.done():
                return
            else:
                failed = self.current_task.exception()
                if failed:
                    self.context.logger.error(f"Error in state {self.current}: {failed}")
                    self.current_task = None
                    self.current = "errorround"
                    return
                self.current_task = None

        current_state = self.get_state(self.current)
        if current_state is None:
            return

        # We check if we need to run the state.
        if not current_state.started:
            self.context.logger.info(f"Starting state {self.current}")
            loop = asyncio.get_event_loop()
            self.current_task = loop.create_task(current_state.act())
            self.current_behaviour = current_state

        if current_state.is_done():
            self.context.logger.info(f"State {self.current} is done.")
            if current_state in self._final_states:
                # we reached a final state - return.
                self.logger.info("Reached a final state.")
                self.current = None
                return
            event = current_state.event
            next_state = self.transitions.get(self.current, {}).get(event, None)
            self.context.logger.info(
                f"Transitioning from state {self.current} with event {event}. Next state: {next_state}"
            )
            self.current = next_state

    def terminate(self) -> None:
        """Implement the termination."""
        print("Terminating the agent.")
        os._exit(0)
