# ------------------------------------------------------------------------------
#
#   Copyright 2024 eightballer
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import sys
import pathlib
import importlib
from typing import TYPE_CHECKING, Any
from datetime import datetime, timedelta

from aea.skills.behaviours import FSMBehaviour
from aea.configurations.base import ComponentType
from aea.configurations.loader import load_component_configuration

from packages.eightballer.skills.simple_fsm.enums import ArbitrageabciappEvents
from packages.eightballer.skills.simple_fsm.strategy import TZ, ArbitrageStrategy
from packages.eightballer.skills.simple_fsm.behaviour_classes.base import BaseBehaviour, BaseConnectionRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.set_approvals import SetApprovalsRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.post_trade_round import PostTradeRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.collect_data_round import CollectDataRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.collect_ticker_round import CollectTickerRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.no_opportunity_round import NoOpportunityRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.order_execution_round import ExecuteOrdersRound
from packages.eightballer.skills.simple_fsm.behaviour_classes.check_bridge_request_round import (
    CheckBridgeRequestRound,
)


if TYPE_CHECKING:
    from packages.zarathustra.protocols.asset_bridging.custom_types import BridgeRequest


DEFAULT_ENCODING = "utf-8"


# Define states

PORTFOLIO_FILE = "portfolio.json"
EXISTING_ORDERS_FILE = "existing_orders.json"
FAILED_ORDERS_FILE = "failed_orders.json"
ORDERS_FILE = "orders.json"
PRICES_FILE = "prices.json"

ORDER_PLACEMENT_TIMEOUT_SECONDS = 10


class UnexpectedStateException(Exception):
    """Exception raised when an unexpected state is reached."""


class IdentifyOpportunityRound(BaseBehaviour):
    """This class implements the IdentifyOpportunityRound state."""

    # we have to import the strategy due to the loading sequence of the agent dependencies.

    def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        self.started = True
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE

        if (
            not self.strategy.state.bridge_requests
            and not self.strategy.state.bridge_requests_in_progress
            and self.strategy.bridging_enabled
        ):
            bridging_requests: list[BridgeRequest] = self.strategy.trading_strategy.get_bridge_requests(
                portfolio=self.strategy.state.portfolio,
                prices=self.strategy.state.prices,
                **self.custom_config.kwargs["strategy_run_kwargs"],
            )
            self.strategy.state.bridge_requests.extend(bridging_requests)
            if bridging_requests:
                self.context.logger.info(f"Bridging requests found: {bridging_requests}")
                self.strategy.send_notification_to_user(
                    title="Bridging requests found",
                    msg=f"Bridging requests found: {bridging_requests}",
                )
                self._event = ArbitrageabciappEvents.BRIDGE_REQUEST_FOUND
                return

        orders = self.strategy.trading_strategy.get_orders(
            portfolio=self.strategy.state.portfolio,
            prices=self.strategy.state.prices,
            orders=self.strategy.state.existing_orders,
            **self.custom_config.kwargs["strategy_run_kwargs"],
        )
        self.strategy.state.unaffordable_opportunity = self.strategy.trading_strategy.unaffordable
        if self.strategy.state.unaffordable_opportunity:
            self.context.logger.info(f"Opportunity unaffordable: {self.strategy.state.unaffordable_opportunity}")
            self.strategy.send_notification_to_user(
                title="Opportunity unaffordable please check",
                msg=f"Opportunity unaffordable: {self.strategy.state.unaffordable_opportunity}",
            )

        # If there are opportunities, we execute those
        if orders:
            self.context.logger.info(f"Opportunity found: {orders}")
            self.strategy.state.new_orders = orders
            self._event = ArbitrageabciappEvents.OPPORTUNITY_FOUND

    def setup(self) -> None:
        """Setup the state."""
        self.started = False
        sys.path.append(".")
        strat_pub_id = self.context.arbitrage_strategy.strategy_public_id

        _dir = "vendor" if pathlib.Path("vendor").exists() else "packages"
        component_dir = pathlib.Path(_dir, strat_pub_id.author, "customs", strat_pub_id.name)
        self.custom_config = load_component_configuration(component_type=ComponentType.CUSTOM, directory=component_dir)

        def validate():
            """Validate the custom configuration."""
            expected_keys = {
                "strategy_class",
                "strategy_init_kwargs",
                "strategy_run_kwargs",
            }
            missing_keys = expected_keys - set(self.custom_config.kwargs.keys())
            if missing_keys:
                msg = (
                    f"Missing keys in custom configuration: {missing_keys} "
                    + f"Please check the configuration. in {self.custom_config.directory}"
                )
                raise ValueError(msg)
            expected_files = {"strategy.py"}
            missing_files = expected_files - set(self.custom_config.fingerprint.keys())
            if missing_files:
                msg = (
                    f"Missing files in custom configuration: {missing_files} "
                    + f"Please check the configuration. in {self.custom_config.directory}"
                )
                raise ValueError(msg)

        validate()
        strategy_class_name: str = self.custom_config.kwargs["strategy_class"]
        strategy_path = str(component_dir / "strategy").replace("/", ".")
        module = importlib.import_module(strategy_path)
        strategy_class = getattr(module, strategy_class_name)
        self.strategy.trading_strategy = strategy_class(**self.strategy.strategy_init_kwargs)
        self.context.logger.debug("Strategy Kwargs:", extra=self.strategy.strategy_init_kwargs)

    @property
    def strategy(self) -> ArbitrageStrategy:
        """Return the strategy."""
        return self.context.arbitrage_strategy


class ErrorRound(BaseBehaviour):
    """This class implements the ErrorRound state."""

    def act(self) -> None:
        """Perform the action of the state."""
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        self.context.logger.info("ErrorRound: Performing action - exiting")
        sys.exit(1)


class CoolDownRound(BaseBehaviour):
    """This class implements the ErrorRound state."""

    sleep_until: datetime | None = None

    def act(self) -> None:
        """Perform the action of the state."""

        if not self.started:
            self._is_done = False
            self.started = True
            error_count = self.strategy.error_count
            backoff = max((2**error_count), 1)
            duration = self.strategy.cooldown_period * backoff
            cool_down = timedelta(seconds=duration)
            self.started_at = datetime.now(tz=TZ)
            self.sleep_until = self.started_at + cool_down
            self.context.logger.info(f"Cool down for {duration}s, error count: {error_count}")
            return

        now = datetime.now(tz=TZ)
        if now < self.sleep_until:
            remaining = (self.sleep_until - now).total_seconds()
            self.context.logger.debug(f"Cooling down remaining: {remaining}s")
            return
        self.context.logger.info(f"Cool down finished. at {now}")
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        self.started = False


class SetupRound(BaseConnectionRound):
    """This class implements the SetupRound state."""

    is_first_run = True

    def act(self) -> None:
        """Perform the action of the state."""
        self.context.logger.debug("SetupRound: Performing action")
        self._event = ArbitrageabciappEvents.DONE

        if self.is_first_run:
            self.context.logger.info("SetupRound: First run")
            self._event = ArbitrageabciappEvents.SET_APPROVALS
            self.is_first_run = False

        self.context.behaviours.main.setup()
        self._is_done = True


class ArbitrageabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state("setupround", SetupRound(**kwargs), True)

        self.register_state("errorround", ErrorRound(**kwargs))
        self.register_state("posttraderound", PostTradeRound(**kwargs), False)
        self.register_state("noopportunityround", NoOpportunityRound(**kwargs))
        self.register_state("cooldownround", CoolDownRound(**kwargs))
        self.register_state("collecttickerround", CollectTickerRound(**kwargs))
        self.register_state("setapprovals", SetApprovalsRound(**kwargs))
        self.register_state("check_bridge_requests_round", CheckBridgeRequestRound(**kwargs))

        self.register_state(
            "identifyopportunityround",
            IdentifyOpportunityRound(**kwargs),
        )
        self.register_state(
            "executeordersround",
            ExecuteOrdersRound(**kwargs),
        )
        self.register_state("collectdataround", CollectDataRound(**kwargs))

        self.register_transition(
            source="setupround",
            event=ArbitrageabciappEvents.DONE,
            destination="collectdataround",
        )

        self.register_transition(
            source="setupround",
            event=ArbitrageabciappEvents.SET_APPROVALS,
            destination="setapprovals",
        )
        self.register_transition(
            source="setapprovals",
            event=ArbitrageabciappEvents.DONE,
            destination="collectdataround",
        )
        self.register_transition(
            source="setapprovals",
            event=ArbitrageabciappEvents.TIMEOUT,
            destination="errorround",
        )

        self.register_transition(
            source="collectdataround",
            event=ArbitrageabciappEvents.DONE,
            destination="collecttickerround",
        )

        self.register_transition(
            source="collecttickerround",
            event=ArbitrageabciappEvents.DONE,
            destination="identifyopportunityround",
        )
        self.register_transition(
            source="collecttickerround",
            event=ArbitrageabciappEvents.TIMEOUT,
            destination="cooldownround",
        )
        self.register_transition(
            source="collectdataround",
            event=ArbitrageabciappEvents.TIMEOUT,
            destination="cooldownround",
        )
        self.register_transition(
            source="cooldownround",
            event=ArbitrageabciappEvents.DONE,
            destination="setupround",
        )
        self.register_transition(
            source="identifyopportunityround",
            event=ArbitrageabciappEvents.OPPORTUNITY_FOUND,
            destination="executeordersround",
        )

        self.register_transition(
            source="identifyopportunityround",
            event=ArbitrageabciappEvents.BRIDGE_REQUEST_FOUND,
            destination="check_bridge_requests_round",
        )
        self.register_transition(
            source="check_bridge_requests_round",
            event=ArbitrageabciappEvents.DONE,
            destination="cooldownround",
        )
        self.register_transition(
            source="identifyopportunityround",
            event=ArbitrageabciappEvents.DONE,
            destination="noopportunityround",
        )
        self.register_transition(
            source="executeordersround",
            event=ArbitrageabciappEvents.DONE,
            destination="posttraderound",
        )
        self.register_transition(
            source="posttraderound",
            event=ArbitrageabciappEvents.DONE,
            destination="cooldownround",
        )
        # register a transation from noopportunityround to setupround
        self.register_transition(
            source="noopportunityround",
            event=ArbitrageabciappEvents.DONE,
            destination="cooldownround",
        )
        # register a transation from executeordersround to errorround
        self.register_transition(
            source="executeordersround",
            event=ArbitrageabciappEvents.ENTRY_EXIT_ERROR,
            destination="setupround",
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.debug("Setting up Arbitrageabciapp FSM behaviour.")
        # We need to setup all the states.
        for state_name in self.states:
            state = self.get_state(state_name)
            state._is_done = False  # noqa
            state.setup()

        self.current_task = None

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Arbitrageabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the behaviour."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
            return

        current_state = self.get_state(self.current)
        if current_state is None:
            return

        # We check if we need to run the state.
        if not current_state.started:
            self.context.logger.debug(f"Starting state {self.current}")
            self.current_task = current_state
            self.current_behaviour = current_state
            self.strategy.state.current_round = str(self.current)

        if current_state.is_done():
            self.context.logger.debug(f"State {self.current} is done.")
            if current_state in self._final_states:
                # we reached a final state - return.
                self.logger.info("Reached a final state.")
                self.current = None
                return
            event = current_state.event
            next_state = self.transitions.get(self.current, {}).get(event, None)
            self.context.logger.info(f"Transitioning: {self.current} --[{event.name}]--> {next_state}")
            self.current = next_state
            self.strategy.state.last_transition_time = datetime.now(tz=TZ)
        self.current_behaviour.act()

    def terminate(self) -> None:
        """Implement the termination."""
        os._exit(0)

    @property
    def strategy(self) -> ArbitrageStrategy:
        """Return the strategy."""
        return self.context.arbitrage_strategy
