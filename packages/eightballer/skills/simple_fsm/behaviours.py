# ------------------------------------------------------------------------------
#
#   Copyright 2023
#   Copyright 2023 valory-xyz
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import sys
import json
import asyncio
import pathlib
import datetime
from enum import Enum
from time import sleep
from typing import Any, cast
from textwrap import dedent
from collections.abc import Callable, Generator

from aea.mail.base import Message
from aea.skills.behaviours import State, FSMBehaviour

from packages.eightballer.connections.dcxt import PUBLIC_ID as DCXT_PUBLIC_ID
from packages.eightballer.protocols.orders.message import OrdersMessage
from packages.eightballer.protocols.tickers.message import TickersMessage
from packages.eightballer.protocols.balances.message import BalancesMessage
from packages.eightballer.protocols.orders.custom_types import Order
from packages.eightballer.connections.apprise.connection import CONNECTION_ID as APPRISE_PUBLIC_ID
from packages.eightballer.connections.dcxt.dcxt.balancer import (
    LEDGER_TO_OLAS,
    LEDGER_TO_WETH,
    LEDGER_TO_STABLECOINS,
    SupportedLedgers,
)
from packages.eightballer.protocols.tickers.custom_types import Tickers
from packages.eightballer.protocols.user_interaction.message import UserInteractionMessage
from packages.eightballer.connections.ccxt_wrapper.connection import PUBLIC_ID as CCXT_PUBLIC_ID
from packages.eightballer.protocols.user_interaction.dialogues import UserInteractionDialogues
from packages.valory.skills.abstract_round_abci.behaviour_utils import BaseBehaviour, TimeoutException


DEFAULT_ENCODING = "utf-8"


# Define states

PORTFOLIO_FILE = "portfolio.json"
EXISTING_ORDERS_FILE = "existing_orders.json"
ORDERS_FILE = "orders.json"
PRICES_FILE = "prices.json"

TIMEOUT_SECONDS = 10

TZ = datetime.datetime.now().astimezone().tzinfo


class SetupRound(State):
    """This class implements the SetupRound state."""

    clear_data = False

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        self.context.logger.info("SetupRound: Performing action")
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)
        if self.clear_data:
            for f in ["orders.json", "portfolio.json", "prices.json"]:
                if pathlib.Path(f).exists():
                    pathlib.Path(f).unlink()
        # We also ensure all behaviours are setup
        self.context.behaviours.main.setup()
        self._is_done = True

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event


class IdentifyOpportunityRound(State):
    """This class implements the IdentifyOpportunityRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done

        # we have to import the strategy due to the loading sequence of the agent dependencies.

    async def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        self.started = True
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        portfolio = json.loads(pathlib.Path(PORTFOLIO_FILE).read_text(encoding="utf-8"))
        prices = json.loads(pathlib.Path(PRICES_FILE).read_text(encoding="utf-8"))
        existing_orders = json.loads(pathlib.Path(EXISTING_ORDERS_FILE).read_text(encoding="utf-8"))

        orders = self.arbitrage_strategy.get_orders(portfolio=portfolio, prices=prices, existing_orders=existing_orders)
        for opportunity in self.arbitrage_strategy.unaffordable:
            self.context.logger.info(f"Opportunity unaffordable: {opportunity[0]}")
        if orders:
            self.context.logger.info(f"Opportunity found: {orders}")
            orders = [json.loads(o.model_dump_json()) for o in orders]
            pathlib.Path(ORDERS_FILE).write_text(json.dumps(orders, indent=4), encoding="utf-8")
            self._event = ArbitrageabciappEvents.OPPORTUNITY_FOUND
        await asyncio.sleep(0)

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event

    def setup(self) -> None:
        """Setup the state."""
        self.started = False
        # We need to add to the PYTHONPATH=. to be able to import the strategy
        sys.path.append(".")
        from vendor.eightballer.customs.arbitrage_strategy import strategy as ArbitrageStrategy  # noqa

        self.arbitrage_strategy = ArbitrageStrategy()


class ErrorRound(State):
    """This class implements the ErrorRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(1)

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event


class BaseConnectionRound(BaseBehaviour):
    """This class implements the BaseConnectionRound state."""

    matching_round = "baseconnectionround"

    def setup(self) -> None:
        """Setup the state."""
        self._performative_to_dialogue_class = {
            OrdersMessage.Performative.GET_ORDERS: self.context.orders_dialogues,
            OrdersMessage.Performative.CREATE_ORDER: self.context.orders_dialogues,
            BalancesMessage.Performative.GET_ALL_BALANCES: self.context.balances_dialogues,
            TickersMessage.Performative.GET_ALL_TICKERS: self.context.tickers_dialogues,
            TickersMessage.Performative.GET_TICKER: self.context.tickers_dialogues,
        }
        self.started = False
        self._is_done = False
        self._message = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self._message = None

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def current_message(self) -> None:
        """Return the current message."""
        return self._message

    def get_response(
        self,
        protocol_performative: Message.Performative,
        connection_id: str,
        **kwargs,
    ) -> Generator[None, None, Any]:
        """Get a ccxt response."""

        dialogue_class = self._performative_to_dialogue_class[protocol_performative]

        msg, dialogue = dialogue_class.create(
            counterparty=str(connection_id),
            performative=protocol_performative,
            **kwargs,
        )
        msg._sender = str(self.context.skill_id)  # noqa
        response = yield from self._do_request(msg, dialogue)
        self._message = None
        return response

    def get_callback_request(self) -> Callable[[Message, "BaseBehaviour"], None]:
        """Wrapper for callback request which depends on whether the message has not been handled on time."""

        def callback_request(message: Message, current_behaviour: BaseBehaviour) -> None:
            """The callback request."""
            self.context.logger.debug(f"Callback request: {message}")
            current_behaviour._message = message  # noqa

        return callback_request

    def wait_for_message(
        self,
        condition: Callable = lambda message: True,  # noqa
        timeout: float | None = None,
    ) -> Any:
        """Wait for message.

        Care must be taken. This method does not handle concurrent requests.
        Use directly after a request is being sent.
        This is a local method that does not depend on the global clock,
        so the usage of datetime.now() is acceptable here.

        """
        if timeout is not None:
            deadline = datetime.datetime.now(tz=TZ) + datetime.timedelta(0, timeout)
        else:
            deadline = datetime.datetime.max

        try:
            while self.current_message is None:
                yield
                if timeout is not None and datetime.datetime.now(tz=TZ) > deadline:
                    raise TimeoutException
            self.context.logger.debug(f"Received message: {self._message}")
            return self.current_message
        except TimeoutException:
            self.context.logger.info("Timeout!")
            return None  # noqa

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event

    async def async_act_wrapper(self) -> Generator[Any, None, None]:
        """Wrapper for the async act method."""
        return await self.async_act()

    async def async_act(self) -> None:
        """Perform the action of the state."""
        self.act()


class ExecuteOrdersRound(BaseConnectionRound):
    """This class implements the ExecuteOrdersRound state."""

    matching_round = "executeordersround"

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False
        self._message = None

    def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        self.started = True

        order_file = pathlib.Path("orders.json")
        orders = order_file.read_text()
        orders = json.loads(orders)
        models = [Order.model_validate(o) for o in orders]
        new_orders = []

        failed_orders = []

        futures = []
        for order in models:
            # We send the orders to the exchange.
            response = self.get_response(
                OrdersMessage.Performative.CREATE_ORDER,
                connection_id=CCXT_PUBLIC_ID if order.ledger_id == "cex" else DCXT_PUBLIC_ID,
                order=order,
                ledger_id=order.ledger_id,
                exchange_id=order.exchange_id,
            )
            futures.append(response)

        for future in futures:
            response = yield from future

            if response.performative == OrdersMessage.Performative.ERROR:
                self.context.logger.error(f"Error creating order: {response.error_code} {response.error_msg} {order}")
                failed_orders.append(order)
                continue

            self.context.logger.info(
                dedent(f"""
            Id: {response.order.id}
            Exchange: {response.order.exchange_id}
            Market:   {response.order.symbol}
            Status:   {response.order.status}
            Side:     {response.order.side}
            Price:    {response.order.price}
            Amount:   {response.order.amount}
            """)
            )
            new_orders.append(response.order)

        new_orders = [json.loads(o.model_dump_json()) for o in new_orders]

        pathlib.Path(ORDERS_FILE).write_text(json.dumps(new_orders, indent=4), encoding="utf-8")
        # We write the orders to disk
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE


class CollectDataRound(BaseConnectionRound):
    """This class implements the CollectDataRound state."""

    matching_round = "collectdataround"

    def act(self) -> Generator:
        """Perform the action of the state."""
        if self.started:
            return

        self.started = True

        portfolio = {}
        ledger_id = "cex"
        prices = {ledger_id: {}}
        existing_orders = {ledger_id: {}}
        portfolio[ledger_id] = {}
        for exchange_id in self.context.arbitrage_strategy.cexs:
            self.context.logger.info(f"Getting balances for {exchange_id} on {ledger_id}")
            balances = yield from self.get_response(
                BalancesMessage.Performative.GET_ALL_BALANCES,
                connection_id=str(CCXT_PUBLIC_ID),
                exchange_id=exchange_id,
                ledger_id=ledger_id,
            )

            if balances.performative == BalancesMessage.Performative.ERROR:
                self.context.logger.error(f"Error getting balances for {exchange_id} on {ledger_id}")
                return self._handle_error()

            self.context.logger.info(f"Got balances for {exchange_id} on {ledger_id}")
            tickers = yield from self.get_response(
                TickersMessage.Performative.GET_ALL_TICKERS,
                connection_id=str(CCXT_PUBLIC_ID),
                exchange_id=exchange_id,
                ledger_id=ledger_id,
            )

            if tickers.performative == TickersMessage.Performative.ERROR:
                self.context.logger.error(f"Error getting tickers for {exchange_id} on {ledger_id}")
                return self._handle_error()

            self.context.logger.info(f"Got tickers for {exchange_id} on {ledger_id}")
            orders = yield from self.get_response(
                OrdersMessage.Performative.GET_ORDERS,
                connection_id=str(CCXT_PUBLIC_ID),
                exchange_id=exchange_id,
                ledger_id=ledger_id,
                symbol="OLAS/USDT",
            )
            if orders.performative == OrdersMessage.Performative.ERROR:
                self.context.logger.error(f"Error getting orders for {exchange_id} on {ledger_id}")
                return self._handle_error()

            self.context.logger.info(f"Got orders for {exchange_id} on {ledger_id}")
            portfolio[ledger_id][exchange_id] = [b.dict() for b in balances.balances.balances]
            prices[ledger_id][exchange_id] = [t.dict() for t in tickers.tickers.tickers]
            existing_orders[ledger_id][exchange_id] = [o.dict() for o in orders.orders.orders]

        for exchange_id, ledger_ids in self.context.arbitrage_strategy.dexs.items():
            for ledger_id in ledger_ids:
                if ledger_id not in portfolio:
                    portfolio[ledger_id] = {}
                if ledger_id not in prices:
                    prices[ledger_id] = {}
                self.context.logger.debug(f"Getting balances for {exchange_id} on {ledger_id}")
                balances = yield from self.get_response(
                    BalancesMessage.Performative.GET_ALL_BALANCES,
                    connection_id=str(DCXT_PUBLIC_ID),
                    exchange_id=exchange_id,
                    ledger_id=ledger_id,
                )
                if balances.performative == BalancesMessage.Performative.ERROR:
                    self.context.logger.error(f"Error getting balances for {exchange_id} on {ledger_id}")
                    return self._handle_error()

                tickers = yield from self.get_tickers(
                    exchange_id=exchange_id,
                    ledger_id=ledger_id,
                )
                if not tickers:
                    self.context.logger.error(f"Error getting tickers for {exchange_id} on {ledger_id}")
                    return self._handle_error()

                self.context.logger.debug(f"Got balances for {exchange_id} on {ledger_id}")
                self.context.logger.debug(f"Got tickers for {exchange_id} on {ledger_id}")
                self.context.logger.debug(f"Balances: {balances}")
                self.context.logger.debug(f"Tickers: {tickers}")
                portfolio[ledger_id][exchange_id] = [b.dict() for b in balances.balances.balances]
                prices[ledger_id][exchange_id] = [t.dict() for t in tickers.tickers]

        # We write the portfolio to disk
        self.context.logger.debug(f"Portfolio: {portfolio}")
        pathlib.Path(PORTFOLIO_FILE).write_text(json.dumps(portfolio, indent=4), encoding="utf-8")
        pathlib.Path(PRICES_FILE).write_text(json.dumps(prices, indent=4), encoding="utf-8")
        pathlib.Path(EXISTING_ORDERS_FILE).write_text(json.dumps([], indent=4), encoding="utf-8")

        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE

    def _handle_error(
        self,
    ) -> None:
        """In the case that data is not retrieved, handled the necessary error."""
        self.started = False
        sleep(TIMEOUT_SECONDS)

    def get_tickers(
        self, exchange_id: str, ledger_id: str, use_weth: bool = True, use_stables: bool = True
    ) -> Generator:
        """Get the tickers from a specific exchange."""
        performative = (
            TickersMessage.Performative.GET_ALL_TICKERS
            if self.context.arbitrage_strategy.fetch_all_tickers
            else TickersMessage.Performative.GET_TICKER
        )

        if performative == TickersMessage.Performative.GET_TICKER:
            # we want to get the wrapped base token
            supported_ledger = SupportedLedgers[ledger_id.upper()]
            asset_a = LEDGER_TO_OLAS[supported_ledger]
            params = []

            def encode_dict(d: dict) -> bytes:
                """Encode a dictionary."""
                return json.dumps(d).encode(DEFAULT_ENCODING)

            if use_weth:
                asset_b = LEDGER_TO_WETH[supported_ledger]
                params.append(
                    {
                        "asset_a": asset_a,
                        "asset_b": asset_b,
                        "params": encode_dict({"amount": self.context.arbitrage_strategy.order_size}),
                    }
                )
            if use_stables:
                for asset_b in LEDGER_TO_STABLECOINS[supported_ledger]:
                    params.append(
                        {
                            "asset_a": asset_a,
                            "asset_b": asset_b,
                            "params": encode_dict({"amount": self.context.arbitrage_strategy.order_size}),
                        }
                    )
            tickers = Tickers(tickers=[])
            for param in params:
                ticker = yield from self.get_response(
                    performative,
                    connection_id=str(DCXT_PUBLIC_ID),
                    exchange_id=exchange_id,
                    ledger_id=ledger_id,
                    **param,
                )
                if ticker.performative == TickersMessage.Performative.ERROR:
                    self.context.logger.error(f"Error getting ticker for {exchange_id} on {ledger_id}")
                    self.started = False
                    sleep(TIMEOUT_SECONDS)
                    return
                tickers.tickers.append(ticker.ticker)

        else:
            tickers = yield from self.get_response(
                performative,
                connection_id=str(DCXT_PUBLIC_ID),
                exchange_id=exchange_id,
                ledger_id=ledger_id,
            )
            if tickers.performative == TickersMessage.Performative.ERROR:
                self.context.logger.error(f"Error getting tickers for {exchange_id} on {ledger_id}")
                self.started = False
                sleep(TIMEOUT_SECONDS)
                return
        return tickers


class PostTradeRound(State):
    """This class implements the PostTradeRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.setup()

    def setup(self) -> None:
        """Setup the state."""
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        self.started = True
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)
        order_file = pathlib.Path("orders.json")
        orders = order_file.read_text()
        orders = json.loads(orders)
        sell_order, buy_order = (Order.model_validate(o) for o in orders)

        def get_explorer_link(order: Order) -> str:
            """Get the explorer link."""
            explorers = {
                "mode": "https://modescan.io/tx/",
                "base": "https://basescan.org/tx/",
                "gnosis": "https://gnosisscan.io/tx/",
            }
            if order.ledger_id not in explorers:
                return ""
            return f"{explorers[order.ledger_id]}{order.id}"

        delta = -(buy_order.price / sell_order.price * 100 - 100)
        value_captured_gross = -(buy_order.price - sell_order.price) * sell_order.amount
        report_msg_table = dedent(f"""
        [Sell]({get_explorer_link(sell_order)}) {sell_order.exchange_id} {sell_order.ledger_id} {sell_order.symbol}

        {sell_order.amount}@{sell_order.price:5f}  total: {sell_order.amount * sell_order.price:5f}

        [Buy]({get_explorer_link(buy_order)}) {buy_order.exchange_id} {buy_order.ledger_id} {buy_order.symbol}

        {buy_order.amount}@{buy_order.price:5f}  total: {buy_order.amount * buy_order.price:5f}

        Delta: {-delta:5f}%
        Value captured: {value_captured_gross:6f}
        """)
        self.send_notification_to_user(
            title="Post Successful Arbitrage Execution!",
            msg=report_msg_table,
        )

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event

    def send_notification_to_user(self, title: str, msg: str, attach: str | None = None) -> None:
        """Send notification to user."""
        dialogues = cast(UserInteractionDialogues, self.context.user_interaction_dialogues)
        msg, _ = dialogues.create(
            counterparty=str(APPRISE_PUBLIC_ID),
            performative=UserInteractionMessage.Performative.NOTIFICATION,
            title=title,
            body=msg,
            attach=attach,
        )
        self.context.outbox.put_message(message=msg)


class NoOpportunityRound(State):
    """This class implements the NoOpportunityRound state."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._is_done = False  # Initially, the state is not done
        self.started = False

    async def act(self) -> None:
        """Perform the action of the state."""
        if self.started:
            return
        self._is_done = True
        self._event = ArbitrageabciappEvents.DONE
        await asyncio.sleep(0)

    def setup(self) -> None:
        """Setup the state."""
        self.started = False
        self._is_done = False
        super().setup()

    def is_done(self) -> bool:
        """Return True if the state is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Return the event."""
        return self._event


class ArbitrageabciappEvents(Enum):
    """This class defines the events for the Arbitrageabciapp FSM."""

    DONE = "DONE"
    TIMEOUT = "TIMEOUT"
    OPPORTUNITY_FOUND = "OPPORTUNITY_FOUND"


class ArbitrageabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state("setupround", SetupRound(**kwargs), True)

        self.register_state("errorround", ErrorRound(**kwargs))
        self.register_state("posttraderound", PostTradeRound(**kwargs), False)
        self.register_state("noopportunityround", NoOpportunityRound(**kwargs))

        self.register_state(
            "identifyopportunityround",
            IdentifyOpportunityRound(**kwargs),
        )
        self.register_state(
            "executeordersround",
            ExecuteOrdersRound(**kwargs),
        )
        self.register_state("collectdataround", CollectDataRound(**kwargs))

        self.register_transition(source="setupround", event=ArbitrageabciappEvents.DONE, destination="collectdataround")
        self.register_transition(
            source="collectdataround", event=ArbitrageabciappEvents.DONE, destination="identifyopportunityround"
        )
        self.register_transition(
            source="identifyopportunityround",
            event=ArbitrageabciappEvents.OPPORTUNITY_FOUND,
            destination="executeordersround",
        )
        self.register_transition(
            source="identifyopportunityround", event=ArbitrageabciappEvents.DONE, destination="noopportunityround"
        )
        self.register_transition(
            source="executeordersround", event=ArbitrageabciappEvents.DONE, destination="posttraderound"
        )
        self.register_transition(source="posttraderound", event=ArbitrageabciappEvents.DONE, destination="setupround")
        # register a transation from noopportunityround to setupround
        self.register_transition(
            source="noopportunityround", event=ArbitrageabciappEvents.DONE, destination="setupround"
        )
        # register a transation from posttraderound to setupround

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Arbitrageabciapp FSM behaviour.")
        # We need to setup all the states.
        for state_name in self.states:
            state = self.get_state(state_name)
            state._is_done = False  # noqa
            state.setup()

        self.current_task = None

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Arbitrageabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the behaviour."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
            return

        if self.current_task:
            if not self.current_task.done():
                return
            failed = self.current_task.exception()
            if failed:
                self.context.logger.error(f"Error in state {self.current}: {self.current_task.print_stack()}")
                self.context.logger.info(f"Breaking on error. {self.current} -> errorround")
                self.current_task = None
                self.current = "errorround"
                return
            self.current_task = None

        current_state = self.get_state(self.current)
        if current_state is None:
            return

        # We check if we need to run the state.
        if not current_state.started:
            self.context.logger.info(f"Starting state {self.current}")
            loop = asyncio.get_event_loop()
            self.current_task = loop.create_task(current_state.act())
            self.current_behaviour = current_state

        if current_state.is_done():
            self.context.logger.info(f"State {self.current} is done.")
            if current_state in self._final_states:
                # we reached a final state - return.
                self.logger.info("Reached a final state.")
                self.current = None
                return
            event = current_state.event
            next_state = self.transitions.get(self.current, {}).get(event, None)
            self.context.logger.info(
                f"Transitioning from state {self.current} with event {event}. Next state: {next_state}"
            )
            self.current = next_state

    def terminate(self) -> None:
        """Implement the termination."""
        os._exit(0)
