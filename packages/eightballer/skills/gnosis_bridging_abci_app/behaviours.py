# ------------------------------------------------------------------------------
#
#   Copyright 2023
#   Copyright 2023 valory-xyz
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import traceback
from abc import ABC
from enum import Enum
from time import sleep
from typing import Any
from dataclasses import asdict

from aea.skills.behaviours import State, FSMBehaviour

from packages.eightballer.skills.gnosis_bridging_abci_app.strategy import BridgingStrategy


class GnosisbridgingabciappEvents(Enum):
    """Events for the fsm."""

    DONE = "DONE"
    TIMEOUT = "TIMEOUT"
    ERROR = "ERROR"
    INSUFFICIENT = "INSUFFICIENT"


class GnosisbridgingabciappStates(Enum):
    """States for the fsm."""

    DEPOSITROUND = "depositround"
    CHECKALLOWANCEROUND = "checkallowanceround"
    STARTROUND = "startround"
    WAITFORMESSAGEROUND = "waitformessageround"
    ENDROUND = "endround"
    CLAIMROUND = "claimround"
    WAITFORSIGNATUREROUND = "waitforsignatureround"
    INCREASEALLOWANCEROUND = "increaseallowanceround"


class BaseState(State, ABC):
    """Base class for states."""

    _state: GnosisbridgingabciappStates = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False  # Initially, the state is not done

    def act(self) -> None:
        """Perform the act."""
        self._is_done = True
        self._event = GnosisbridgingabciappEvents.DONE

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Current event."""
        return self._event

    @property
    def strategy(self) -> BridgingStrategy:
        """Get the strategy."""
        return self.context.bridging_strategy


class CheckAllowanceRound(BaseState):
    """This class implements the behaviour of the state CheckAllowanceRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GnosisbridgingabciappStates.CHECKALLOWANCEROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info("Checking allowance")
        try:
            ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
            ledger_api = self.strategy.l1_ledger_api if ledger_to_spend == "ethereum" else self.strategy.l2_ledger_api
            self.context.logger.info(
                f"Checking allowance on {ledger_to_spend} on {self.strategy.current_bridge_request.from_bridge_address}"
            )
            allowance = self.strategy.erc_20.allowance(
                ledger_api=ledger_api,
                **asdict(self.strategy.current_bridge_request.get_allowance_data(self.strategy.crypto)),
            )["int"]
            if allowance < self.strategy.current_bridge_request.amount:
                # leave loads of emojis in the code.
                self.context.logger.info("Insufficient allowance for depositðŸ¤¯")
                self._event = GnosisbridgingabciappEvents.INSUFFICIENT
            else:
                self.context.logger.info("Sufficient allowance for deposit! ðŸš€")
            self._event = GnosisbridgingabciappEvents.DONE
        except Exception:  # noqa
            self._event = GnosisbridgingabciappEvents.ERROR

        finally:
            self._is_done = True


class StartRound(BaseState):
    """This class implements the behaviour of the state StartRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GnosisbridgingabciappStates.STARTROUND

    def act(self) -> None:
        """Perform the act."""
        try:
            self.context.logger.info("Checking for bridge requests")
            if not self.strategy.current_bridge_request:
                new_request = self.strategy.bridge_requests.pop(0)
                self.strategy.current_bridge_request = new_request
            self._event = GnosisbridgingabciappEvents.DONE
        except Exception:  # noqa
            self._event = GnosisbridgingabciappEvents.ERROR
        finally:
            self._is_done = True


class EndRound(BaseState):
    """This class implements the behaviour of the state EndRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GnosisbridgingabciappStates.ENDROUND


class IncreaseAllowanceRound(BaseState):
    """This class implements the behaviour of the state IncreaseAllowanceRound."""

    _state = GnosisbridgingabciappStates.INCREASEALLOWANCEROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info("Increasing allowance")
        try:
            ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
            ledger_api = self.strategy.l1_ledger_api if ledger_to_spend == "ethereum" else self.strategy.l2_ledger_api
            self.context.logger.info(
                f"Increasing limit for: {ledger_to_spend} on {self.strategy.current_bridge_request.from_bridge_address}"
            )
            w3_function = self.strategy.erc_20.approve(
                ledger_api=ledger_api,
                amount=self.strategy.current_bridge_request.amount,
                **asdict(self.strategy.current_bridge_request.get_allowance_data(self.strategy.crypto)),
            )
            result, txn_hash = self.strategy.sign_and_send_txn(w3_function, self.strategy.crypto, ledger_api)
            self.context.logger.info(f"Txn hash: {txn_hash}")
            if not result:
                self.context.logger.info("Failed to increase allowance")
                self._event = GnosisbridgingabciappEvents.ERROR
            else:
                self.context.logger.info("Increased allowance successfully!")
                self._event = GnosisbridgingabciappEvents.DONE
        except Exception:  # noqa
            self._event = GnosisbridgingabciappEvents.ERROR
        finally:
            self._is_done = True


class DepositRound(BaseState):
    """This class implements the behaviour of the state DepositRound."""

    _state = GnosisbridgingabciappStates.DEPOSITROUND

    def act(self):
        """Send the deposit transaction."""
        self.context.logger.info("Depositing tokens")
        try:
            ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
            ledger_api = self.strategy.l1_ledger_api if ledger_to_spend == "ethereum" else self.strategy.l2_ledger_api
            self.context.logger.info(
                f"Depositing tokens on {ledger_to_spend} for {self.strategy.current_bridge_request.from_bridge_address}"
            )
            function = self.strategy.current_bridge_request.deposit_function
            w3_function = function(
                ledger_api=ledger_api,
                **asdict(self.strategy.current_bridge_request.get_deposit_data(self.strategy.crypto)),
            )
            txn = self.strategy.build_transaction(w3_function, self.strategy.crypto, ledger_api)
            result, txn_hash = self.strategy.sign_and_send_txn(txn, self.strategy.crypto, ledger_api)
            self.context.logger.info(f"Txn hash: {txn_hash}")
            self.strategy.current_bridge_request.deposit_txn = txn_hash
            if not result:
                self.context.logger.info("Failed to deposit tokens")
                self._event = GnosisbridgingabciappEvents.ERROR
            else:
                self.context.logger.info("Tokens deposited successfully! ðŸš€")
                self._event = GnosisbridgingabciappEvents.DONE
        except Exception as e:
            self.context.logger.exception(traceback.format_exc())
            self.context.logger.exception(f"Error depositing tokens: {e}")
            self._event = GnosisbridgingabciappEvents.ERROR
        finally:
            self._is_done = True


class WaitForMessageRound(BaseState):
    """This class implements the behaviour of the state WaitForMessageRound."""

    _state: GnosisbridgingabciappStates = GnosisbridgingabciappStates.WAITFORMESSAGEROUND

    def act(self) -> None:
        """Perform the act."""
        ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
        self.context.logger.info(f"Waiting for message on {ledger_to_spend}")
        try:
            ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
            ledger_api = self.strategy.l1_ledger_api if ledger_to_spend == "ethereum" else self.strategy.l2_ledger_api
            self.context.logger.info(
                f"Waiting for event on {ledger_to_spend} for {self.strategy.current_bridge_request.from_bridge_address}"
            )
            receipt = ledger_api.api.eth.wait_for_transaction_receipt(
                self.strategy.current_bridge_request.deposit_txn, timeout=600
            )
            msg = receipt["logs"][-3]["data"]
            msg_id = receipt["logs"][-3]["topics"][-1]
            msg_data = "0x" + str(msg.hex())[130 : len(msg.hex()) - 22]
            self.strategy.current_bridge_request.msg = msg.hex()
            self.strategy.current_bridge_request.msg_id = msg_id.hex()
            self.strategy.current_bridge_request.msg_data = msg_data
            self._event = GnosisbridgingabciappEvents.DONE
            self.context.logger.info("Message ID successfully retrived from mainnet: ")
            self.context.logger.info(msg_id.hex())

        except Exception:
            self.context.logger.exception(traceback.format_exc())
            self._event = GnosisbridgingabciappEvents.ERROR
        finally:
            self._is_done = True


class WaitForSignatureRound(BaseState):
    """This class implements the behaviour of the state WaitForSignatureRound."""

    _state: GnosisbridgingabciappStates = GnosisbridgingabciappStates.WAITFORSIGNATUREROUND

    def act(self):
        """Wait for signature."""
        self.context.logger.info("Waiting for signature")

        if self.strategy.current_bridge_request.from_ledger_id == "ethereum":
            address = self.strategy.current_bridge_request.l2_minter_address
            ledger_api = self.strategy.l2_ledger_api

            events = self.strategy.l2_amb.get_tokens_bridged_events(
                ledger_api=ledger_api,
                contract_address=address,
                look_back=10_000,
                message_id=self.strategy.current_bridge_request.msg_id,
            )
            if not events.get("events"):
                self.context.logger.info("No events found yet. Waiting for 30 seconds.")
                sleep(30)
                return self.act()

            self.context.logger.info(
                f"Successully bridged tokens to {self.strategy.current_bridge_request.to_ledger_id}"
            )
            self.strategy.current_bridge_request.claim_txn = events.get("events")[0]["transactionHash"].hex()
            self._event = GnosisbridgingabciappEvents.DONE
            self._is_done = True
            return None
        if self.strategy.current_bridge_request.from_ledger_id == "gnosis":
            ledger_api = self.strategy.l2_ledger_api
            req = self.strategy.current_bridge_request
            contract = req.signing_bridge_contract
            message = req.msg_data
            while True:
                try:
                    func = contract.get_signatures(
                        ledger_api=ledger_api,
                        contract_address=req.amb_helper_address,
                        message=message,
                    )
                    signatures = "0x" + str(func["str"].hex())
                    self.strategy.current_bridge_request.signatures = signatures
                    self._event = GnosisbridgingabciappEvents.DONE
                    self._is_done = True
                    return None
                except Exception as e:
                    self.context.logger.exception(traceback.format_exc())
                    self.context.logger.info(f"Still waiting for signatures: {e}")
                    sleep(30)
                    continue
        self._event = GnosisbridgingabciappEvents.ERROR
        self._is_done = True
        return None


class ClaimRound(BaseState):
    """This class implements the behaviour of the state ExecuteOnMainnetRound."""

    _state = GnosisbridgingabciappStates.CLAIMROUND

    def act(self):
        """Check if necessary to claim tokens."""

        ledger_to_spend = self.strategy.current_bridge_request.from_ledger_id
        if ledger_to_spend == "ethereum":
            self._event = GnosisbridgingabciappEvents.DONE
            self._is_done = True
            return
        self.context.logger.info("Claiming tokens")
        ledger_api = self.strategy.l1_ledger_api
        function = self.strategy.current_bridge_request.get_claim_function()
        request = self.strategy.current_bridge_request

        try:
            w3_function = function(
                ledger_api=ledger_api,
                data=request.msg_data,
                signatures=request.signatures,
                contract_address=request.l1_claimer_address,
            )
            txn = self.strategy.build_transaction(w3_function, self.strategy.crypto, ledger_api)
            result = self.strategy.sign_and_send_txn(txn, self.strategy.crypto, ledger_api)
            if not result:
                self.context.logger.info("Failed to claim tokens")
                self._event = GnosisbridgingabciappEvents.ERROR
            else:
                self.context.logger.info("Tokens claimed successfully! ðŸš€")
                self._event = GnosisbridgingabciappEvents.DONE
        except Exception:
            self.context.logger.exception(traceback.format_exc())
            self.context.logger.exception("Error claiming tokens")
            self._event = GnosisbridgingabciappEvents.ERROR
        finally:
            self._is_done = True


class GnosisbridgingabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state(GnosisbridgingabciappStates.STARTROUND.value, StartRound(**kwargs), True)

        self.register_state(GnosisbridgingabciappStates.ENDROUND.value, EndRound(**kwargs))

        self.register_state(GnosisbridgingabciappStates.DEPOSITROUND.value, DepositRound(**kwargs))
        self.register_state(GnosisbridgingabciappStates.CHECKALLOWANCEROUND.value, CheckAllowanceRound(**kwargs))
        self.register_state(GnosisbridgingabciappStates.WAITFORMESSAGEROUND.value, WaitForMessageRound(**kwargs))
        self.register_state(GnosisbridgingabciappStates.CLAIMROUND.value, ClaimRound(**kwargs))
        self.register_state(GnosisbridgingabciappStates.WAITFORSIGNATUREROUND.value, WaitForSignatureRound(**kwargs))
        self.register_state(GnosisbridgingabciappStates.INCREASEALLOWANCEROUND.value, IncreaseAllowanceRound(**kwargs))

        self.register_transition(
            source=GnosisbridgingabciappStates.CHECKALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.INSUFFICIENT,
            destination=GnosisbridgingabciappStates.INCREASEALLOWANCEROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.CHECKALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.DEPOSITROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.CHECKALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.DEPOSITROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.WAITFORMESSAGEROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.DEPOSITROUND.value,
            event=GnosisbridgingabciappEvents.ERROR,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.DEPOSITROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.CLAIMROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.CLAIMROUND.value,
            event=GnosisbridgingabciappEvents.ERROR,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.CLAIMROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.INCREASEALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.DEPOSITROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.INCREASEALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.ERROR,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.INCREASEALLOWANCEROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.STARTROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.CHECKALLOWANCEROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORMESSAGEROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.WAITFORSIGNATUREROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORMESSAGEROUND.value,
            event=GnosisbridgingabciappEvents.ERROR,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORMESSAGEROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORSIGNATUREROUND.value,
            event=GnosisbridgingabciappEvents.DONE,
            destination=GnosisbridgingabciappStates.CLAIMROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORSIGNATUREROUND.value,
            event=GnosisbridgingabciappEvents.ERROR,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )
        self.register_transition(
            source=GnosisbridgingabciappStates.WAITFORSIGNATUREROUND.value,
            event=GnosisbridgingabciappEvents.TIMEOUT,
            destination=GnosisbridgingabciappStates.ENDROUND.value,
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Gnosisbridgingabciapp FSM behaviour.")

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Gnosisbridgingabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the act."""
        super().act()
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()

    def terminate(self) -> None:
        """Implement the termination."""
        os._exit(0)
