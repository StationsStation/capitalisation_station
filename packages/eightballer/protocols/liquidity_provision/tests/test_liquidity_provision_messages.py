# Auto-generated by tool

"""Test messages module for the liquidity_provision protocol."""

from pydantic import BaseModel
from hypothesis import HealthCheck, given, settings, strategies as st
from aea.mail.base import Envelope

from packages.eightballer.protocols.liquidity_provision.message import LiquidityProvisionMessage
from packages.eightballer.protocols.liquidity_provision.tests.performatives import (
    Error,
    AddLiquidity,
    LiquidityAdded,
    QueryLiquidity,
    LiquidityStatus,
    RemoveLiquidity,
    LiquidityRemoved,
)


def shallow_dump(model: BaseModel) -> dict:
    """Shallow dump pydantic model."""

    return {name: getattr(model, name) for name in model.__class__.model_fields}


def perform_message_test(performative, model) -> None:
    """Test message encode/decode."""

    msg = LiquidityProvisionMessage(
        performative=performative,
        **shallow_dump(model),
    )

    msg.to = "receiver"
    assert msg._is_consistent()  # noqa: SLF001
    envelope = Envelope(to=msg.to, sender="sender", message=msg)
    envelope_bytes = envelope.encode()

    actual_envelope = Envelope.decode(envelope_bytes)
    expected_envelope = envelope

    assert expected_envelope.to == actual_envelope.to
    assert expected_envelope.sender == actual_envelope.sender
    assert expected_envelope.protocol_specification_id == actual_envelope.protocol_specification_id
    assert expected_envelope.message != actual_envelope.message

    actual_msg = LiquidityProvisionMessage.serializer.decode(actual_envelope.message_bytes)
    actual_msg.to = actual_envelope.to
    actual_msg.sender = actual_envelope.sender
    expected_msg = msg
    assert expected_msg == actual_msg


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(AddLiquidity))
def test_add_liquidity_messages(model):
    """Test for the 'ADD_LIQUIDITY' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.ADD_LIQUIDITY, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(RemoveLiquidity))
def test_remove_liquidity_messages(model):
    """Test for the 'REMOVE_LIQUIDITY' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.REMOVE_LIQUIDITY, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(QueryLiquidity))
def test_query_liquidity_messages(model):
    """Test for the 'QUERY_LIQUIDITY' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.QUERY_LIQUIDITY, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(LiquidityAdded))
def test_liquidity_added_messages(model):
    """Test for the 'LIQUIDITY_ADDED' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.LIQUIDITY_ADDED, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(LiquidityRemoved))
def test_liquidity_removed_messages(model):
    """Test for the 'LIQUIDITY_REMOVED' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.LIQUIDITY_REMOVED, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(LiquidityStatus))
def test_liquidity_status_messages(model):
    """Test for the 'LIQUIDITY_STATUS' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.LIQUIDITY_STATUS, model)


@settings(deadline=1000, suppress_health_check=[HealthCheck.too_slow])
@given(st.from_type(Error))
def test_error_messages(model):
    """Test for the 'ERROR' protocol message encode and decode."""

    perform_message_test(LiquidityProvisionMessage.Performative.ERROR, model)
